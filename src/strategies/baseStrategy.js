const logger = require('../utils/logger');

class BaseStrategy {
  constructor(name, parameters = {}) {
    this.name = name;
    this.parameters = parameters;
    this.isActive = false;
    this.tradingEngine = null;
    this.coinbaseService = null;
    this.unsubscribe = null;
    
    // Performance tracking
    this.trades = [];
    this.totalProfit = 0;
    this.totalLoss = 0;
    this.winRate = 0;
    this.startTime = null;
    
    // Signal tracking
    this.signals = [];
    this.lastSignal = null;
  }

  async start() {
    if (this.isActive) {
      throw new Error(`Strategy ${this.name} is already active`);
    }

    // Get services from global
    this.tradingEngine = global.tradingBot?.tradingEngine;
    this.coinbaseService = global.tradingBot?.coinbaseService;

    if (!this.tradingEngine || !this.coinbaseService) {
      throw new Error('Trading engine or Coinbase service not available');
    }

    // Note: Market data is forwarded from main server, no need to subscribe directly

    this.isActive = true;
    this.startTime = new Date();
    
    logger.info(`Strategy started: ${this.name}`);
    
    // Call strategy-specific initialization
    if (this.onStart) {
      await this.onStart();
    }
  }

  async stop() {
    if (!this.isActive) return;

    // Note: No need to unsubscribe since we don't subscribe directly anymore

    this.isActive = false;
    
    logger.info(`Strategy stopped: ${this.name}`);
    
    // Call strategy-specific cleanup
    if (this.onStop) {
      await this.onStop();
    }
  }

  handleMarketData(event, data) {
    if (!this.isActive) return;

    switch (event) {
      case 'price':
        if (this.onPriceUpdate) {
          this.onPriceUpdate(data);
        }
        break;
      case 'trade':
        if (this.onTradeUpdate) {
          this.onTradeUpdate(data);
        }
        break;
      case 'orderbook':
        if (this.onOrderBookUpdate) {
          this.onOrderBookUpdate(data);
        }
        break;
    }
  }

  async generateBuySignal(signalData) {
    const signal = {
      type: 'buy',
      timestamp: new Date(),
      strategy: this.name,
      data: signalData
    };

    this.signals.push(signal);
    this.lastSignal = signal;

    logger.info(`Buy signal generated by ${this.name}:`, signalData);

    // Execute trade if auto-trading is enabled
    if (this.parameters.autoTrade) {
      await this.executeBuyOrder(signalData);
    }

    // Emit signal event
    if (this.onSignal) {
      this.onSignal(signal);
    }
  }

  async generateSellSignal(signalData) {
    const signal = {
      type: 'sell',
      timestamp: new Date(),
      strategy: this.name,
      data: signalData
    };

    this.signals.push(signal);
    this.lastSignal = signal;

    logger.info(`Sell signal generated by ${this.name}:`, signalData);

    // Execute trade if auto-trading is enabled
    if (this.parameters.autoTrade) {
      await this.executeSellOrder(signalData);
    }

    // Emit signal event
    if (this.onSignal) {
      this.onSignal(signal);
    }
  }

  async executeBuyOrder(signalData) {
    try {
      const amount = this.parameters.tradeAmount || process.env.DEFAULT_TRADE_AMOUNT || 0.01;
      const productId = this.parameters.productId || 'BTC-USD';
      
      const result = await this.tradingEngine.executeBuyOrder(productId, amount);
      
      if (result.success) {
        this.recordTrade({
          type: 'buy',
          amount,
          price: signalData.price,
          orderId: result.order.id,
          timestamp: new Date(),
          signal: signalData
        });
      }
      
      return result;
    } catch (error) {
      logger.error(`Error executing buy order for ${this.name}:`, error);
      return { success: false, error: error.message };
    }
  }

  async executeSellOrder(signalData) {
    try {
      const amount = this.parameters.tradeAmount || process.env.DEFAULT_TRADE_AMOUNT || 0.01;
      const productId = this.parameters.productId || 'BTC-USD';
      
      const result = await this.tradingEngine.executeSellOrder(productId, amount);
      
      if (result.success) {
        this.recordTrade({
          type: 'sell',
          amount,
          price: signalData.price,
          orderId: result.order.id,
          timestamp: new Date(),
          signal: signalData
        });
      }
      
      return result;
    } catch (error) {
      logger.error(`Error executing sell order for ${this.name}:`, error);
      return { success: false, error: error.message };
    }
  }

  recordTrade(trade) {
    this.trades.push(trade);
    this.calculatePerformance();
  }

  calculatePerformance() {
    if (this.trades.length < 2) return;

    let profit = 0;
    let loss = 0;
    let wins = 0;
    let losses = 0;

    // Simple P&L calculation (buy low, sell high)
    for (let i = 1; i < this.trades.length; i++) {
      const prevTrade = this.trades[i - 1];
      const currentTrade = this.trades[i];
      
      if (prevTrade.type === 'buy' && currentTrade.type === 'sell') {
        const pnl = (currentTrade.price - prevTrade.price) * prevTrade.amount;
        if (pnl > 0) {
          profit += pnl;
          wins++;
        } else {
          loss += Math.abs(pnl);
          losses++;
        }
      }
    }

    this.totalProfit = profit;
    this.totalLoss = loss;
    this.winRate = wins + losses > 0 ? (wins / (wins + losses)) * 100 : 0;
  }

  getPerformance() {
    return {
      strategy: this.name,
      isActive: this.isActive,
      startTime: this.startTime,
      totalTrades: this.trades.length,
      totalProfit: this.totalProfit,
      totalLoss: this.totalLoss,
      netProfit: this.totalProfit - this.totalLoss,
      winRate: this.winRate,
      signals: this.signals.length,
      lastSignal: this.lastSignal,
      parameters: this.parameters
    };
  }

  getSignals(limit = 10) {
    return this.signals.slice(-limit);
  }

  getTrades(limit = 10) {
    return this.trades.slice(-limit);
  }

  // Abstract methods to be implemented by concrete strategies
  onPriceUpdate(data) {
    // Override in concrete strategy
  }

  onTradeUpdate(data) {
    // Override in concrete strategy
  }

  onOrderBookUpdate(data) {
    // Override in concrete strategy
  }

  onStart() {
    // Override in concrete strategy
  }

  onStop() {
    // Override in concrete strategy
  }

  onSignal(signal) {
    // Override in concrete strategy
  }

  getIndicators() {
    // Override in concrete strategy to return strategy-specific indicators
    return {};
  }

  getDescription() {
    // Override in concrete strategy to return strategy description
    return `${this.name} trading strategy`;
  }
}

module.exports = BaseStrategy;
